# 彻底弄懂强缓存与协商缓存

## 一、前言



在工作中，前端代码打包之后的生成的静态资源就要发布到静态服务器上，这时候就要做对这些静态资源做一些运维配置，其中，gzip和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。

首先，什么是缓存？我的理解，缓存就是一个**资源副本**。当我们向服务器请求资源后，会根据情况将资源 copy 一份副本存在本地，以方便下次读取。它与本地存储 `localStorage` 、`cookie` 等不同，本地存储更多是**数据记录**，存储量较小，为了本地操作方便。而缓存更多是为了减少资源请求，多用于存储文件，存储量相对较大。

那缓存有啥用呢？缓存最根本的作用就是**减少没必要请求**。有些资源，比如用户头像图片，很久才改变一次，但每次都要去请求这张一样的图片，通信一来一回增加了页面的显示时长，过多没必要请求也增加了服务器的压力。如果把这张图片直接缓存在本地，那每次就可以直接本地读取加载，不再发起请求。所以缓存的好处也就显而易见了，**减少了时长从而优化用户体验，也减少了流量消耗，减轻了服务器的压力**。

那么，缓存有哪些呢？就浏览器而言，一般缓存我们分为四类，按浏览器读取优先级顺序依次为：`Memory Cache`、`Service Worker Cache`、`HTTP Cache`、`Push Cache`。而本篇文章主要讲的就是 `HTTP Cache` ，其他有兴趣可以自行搜索。

缓存的优点：

- 减少了不必要的数据传输，节省带宽
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度
- 用户体验友好

缺点：

- 资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有bug的话，情况会更加糟糕。

**所以，为了避免设置缓存错误，掌握缓存的原理对于我们工作中去更加合理的配置缓存是非常重要的。**

## 二、浏览器缓存

缓存这东西，第一次必须获取到资源后，而后根据返回的信息来告诉如何缓存资源，可能采用的是强缓存，也可能告诉客户端浏览器是协商缓存，这都须要根据响应的header内容来决定的。下面用两幅图来描述浏览器的缓存是怎么玩的，让你们有个大概的认知。html

浏览器第一次请求时：浏览器

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027e011935054e128503ac400d600e19~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

浏览器后续在进行请求时：缓存

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4533f54c2d364c59bdc5b967ec4253f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

从上图能够知道，浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：服务器

- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通讯；在firebug下能够查看某个具备强缓存资源返回的信息，例如本地firebug查看的一个强缓存js文件

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fa53ce477e45eb954a0fe7e9f5c1a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 若是没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，可是并不返回资源内容，它会告知浏览器能够直接从缓存获取；不然返回最新的资源内容

强缓存与协商缓存的区别，能够用下表来进行描述：代理

**获取资源形式**

**状态码**

**发送请求到服务器**

**强缓存**

从缓存取

200（from cache）

否，直接从缓存取

**协商缓存**

从缓存取

304（not modified）

是，正如其名，经过服务器来告知缓存是否可用

## 三、强缓存相关的header字段

强缓存上面已经介绍了，直接从缓存中获取资源而不通过服务器；与强缓存相关的header字段有两个：htm

1. **expires**，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，若是发送请求的时间在expires以前，那么本地缓存始终有效，不然就会发送请求到服务器来获取资源
2. **cache-control：max-age=number**，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过时时间，再拿这个过时时间跟当前的请求时间比较，若是请求时间在过时时间以前，就能命中缓存，不然就不行；cache-control除了该字段外，还有下面几个比较经常使用的设置值：
   - no-cache：不使用本地缓存。须要使用缓存协商，先与服务器确认返回的响应是否被更改，若是以前的响应中存在ETag，那么请求的时候会与服务端验证，若是资源未被更改，则能够避免从新下载。
   - no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
   - public：能够被全部的用户缓存，包括终端用户和CDN等中间代理服务器。
   - private：只能被终端用户的浏览器缓存，不容许CDN等中继缓存服务器对其缓存。

　　注意：若是cache-control与expires同时存在的话，cache-control的优先级高于expiresblog

## 四、协商缓存相关的header字段

协商缓存都是由服务器来肯定缓存资源是否可用的，因此客户端与服务器端要经过某种标识来进行通讯，从而让服务器判断请求资源是否能够缓存访问，这主要涉及到下面两组header字段，**这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有**Last-Modified或者Etag**字段，则请求头也不会有对应的字段**。资源

1. Last-Modified/If-Modified-Since

   两者的值都是GMT格式的时间字符串，具体过程：

   - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间
   - 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值
   - 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，若是没有变化则返回304 Not Modified，可是不会返回资源内容；若是有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，由于既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header
   - 浏览器收到304的响应后，就会从缓存中加载资源
   - 若是协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在从新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值

2. **Etag/If-None-Match**
    这两个值是由服务器生成的每一个资源的惟一标识字符串，只要资源有变化就这个值就会改变；其判断过程与**Last-Modified/If-Modified-Since**相似，与Last-Modified不同的是，当服务器返回304 Not Modified的响应时，因为ETag从新生成过，response header中还会把这个ETag返回，即便这个ETag跟以前的没有变化。

## 五、既生Last-Modified何生Etag

> 你可能会以为使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为何还须要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

- 一些文件也许会周期性的更改，可是他的内容并不改变(仅仅改变的修改时间)，这个时候咱们并不但愿客户端认为这个文件被修改了，而从新GET；开发
- 某些文件修改很是频繁，好比在秒如下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改没法判断(或者说UNIX记录MTIME只能精确到秒)；字符串
- 某些服务器不能精确的获得文件的最后修改时间。

这时，利用Etag可以更加准确的控制缓存，由于Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的惟一标识符。

Last-Modified与ETag是能够一块儿使用的，服务器会优先验证ETag，一致的状况下，才会继续比对Last-Modified，最后才决定是否返回304。

## 六、访问刷新分析

我们将访问和刷新分为以下三种情况：

- 标签进入、输入url回车进入
- 按刷新按钮、F5 刷新、网页右键“重新加载”
- ctrl + F5 强制刷新

假设当前有这么一个 index 页面，返回的响应信息如下：

```http
cache-control: max-age=72000
expires: Tue, 20 Nov 2018 20:41:14 GMT
last-modified: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 1、标签进入、输入url回车进入

这种情况下会根据实际设计的缓存策略去判断。

1. 由于该例没有设置 `no-cache` 和 `no-store`，所以默认先走强缓存路线。根据 `cache-control` （`expires` 优先级低）判断缓存是否过期，若没有过期则此时返回 `200(from cache)`。
2. 若本地缓存已经过期再走协商缓存路线，根据之前的 `last-modified` 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 `304(not modified)`。
3. 否则返回新的资源，状态码 `200(ok)`，并更新返回响应的 `last-modified` 值。

##### 2、按刷新按钮、F5 刷新、网页右键“重新加载”

这种情况下，实际是浏览器将 `cache-control` 的 `max-age` 直接设置成了 0，让缓存立即过期，直接走协商缓存路线。发送的请求头如下：

```http
cache-control: max-age=0
if-modified-since: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 3、ctrl + F5 强制刷新

强制刷新的情况下，浏览器会强行设置 `no-cache`，强制获取最新的资源，就连 `if-modified-since` 等其他缓存协议字段都会被吃掉。此时发送的请求头如下：

```http
cache-control: no-cache
pragma: no-cache
```

## 七、参考链接

[彻底弄懂强缓存与协商缓存](https://juejin.cn/post/7066696811523604510#heading-5)

[强缓存和协商缓存](https://www.jianshu.com/p/fb59c770160c)